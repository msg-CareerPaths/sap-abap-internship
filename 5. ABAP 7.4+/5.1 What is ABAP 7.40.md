# What is ABAP 7.40?

The technical innovations in SAP are coming in rapid succession. It should therefore not come as a surprise that even the ABAP language is undergoing transformations.

ABAP 7.4 is a modern programming approach introduced by SAP which increases the code efficiency, making it easier for the developers. 
It includes new features such as Inline Declaration, Table Expression and Data Operations. 

The following figure summarizes the evolution of the ABAP codelines:
![image](https://github.com/msg-CareerPaths/sap-abap-internship/assets/92362724/cf2e2a4f-4550-4b17-9e05-da22187948b4)

## Features

- [Inline Declarations](#inline-declarations)
- [Table Expressions](#table-expressions)
- [Conversion Operator CONV](#conversion-operator-conv)
- [VALUE Operator](#value-operator)
- [FOR Operator](#for-operator)
- [Reduction Operator REDUCE](#reduction-operator-reduce)
- [Conditional operators COND and SWITCH](#conditional-operators-cond-and-switch)
- [CORRESPONDING Operator](#corresponding-operator)
- [Strings](#strings)
- [Loop at Group by](#loop-at-group-by)
- [Classes/Methods](#classes-and-methods)
- [Filter](#filter)


### Inline Declarations

- Data
  
  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `DATA text TYPE string.`</br>`text = 'ABC'.` | `DATA(text) = 'ABC'.` |

- Loop at into work area

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `DATA wa like LINE OF itab.` </br> `LOOP AT itab INTO wa.` </br> `...` </br> `ENDLOOP.` | `LOOP AT itab INTO DATA(wa).` </br> `...` </br> `ENDLOOP.` |
  
- Call method

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `DATA a1 TYPE ...` </br> `DATA a2 TYPE ...` </br>  `oref->meth(` </br>  `IMPORTING p1 = a1` </br> `IMPORTING p2 = a2 ).`| `oref->meth(` </br> `IMPORTING p1 = DATA(a1)` </br> `IMPORTING p2 = DATA(a2) ).`|
  
- Loop at assigning

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `FIELD-SYMBOLS: <line> type …` </br>  `LOOP AT itab ASSIGNING <line>.` </br> `...` </br> `ENDLOOP.` | `LOOP AT itab ASSIGNING FIELD-SYMBOL(<line>).` </br> `...` </br> `ENDLOOP.` |
  
- Read assigning

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `FIELD-SYMBOLS: <line> type …` </br> `READ TABLE itab ASSIGNING <line>.`  | `READ TABLE itab ASSIGNING FIELD-SYMBOL(<line>).` |
  
- Select into table

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `DATA itab TYPE TABLE OF dbtab.` </br> `SELECT * FROM dbtab` </br> `INTO TABLE itab` </br> `WHERE fld1 = lv_fld1.` | `SELECT * FROM dbtab` </br> `INTO TABLE @DATA(itab)` </br> `WHERE fld1 = @lv_fld1.` |
  
- Select single into

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `SELECT SINGLE f1 f2` </br>`FROM dbtab` </br>`INTO (lv_f1, lv_f2`</br>`WHERE ...`</br>`WRITE: / lv_f1, lv_f2.` | `SELECT SINGLE f1 AS my_f1,f2 AS abc`</br> `FROM dbtab`</br>`INTO DATA(ls_struct)`</br>`WHERE ...`</br>`WRITE: / ls_struct-my_f1, ls_struct-abc.` |

### Table Expressions

- Read Table index

  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `READ TABLE itab INDEX idx INTO wa.` | `wa = itab[ idx ].` |
  
- Read Table using key
  
  | Before 7.4 | After 7.4 |
  | --- | --- |
  | `READ TABLE itab INDEX idx` </br> `  USING KEY key` </br> `  INTO wa.` | `wa = itab[ KEY key INDEX idx ].` |
  
- Read Table with key

  | Before 7.4 | After 7.4 |
  | --- | --- |
  |`READ TABLE itab` </br>`  WITH KEY col1 = … col2 = …` </br> `  INTO wa.`| `wa = itab[ col1 = … col2 = … ].` |
  
- Read Table with key components

  | Before 7.4 | After 7.4 |
  | --- | --- |
  |`READ TABLE itab`</br> `  WITH TABLE KEY key` </br> `  COMPONENTS col1 = …  col2 = …`</br> `  INTO wa.`|`wa = itab[ KEY key col1 = … col2 = … ].`|
  
- Does record exist?

  | Before 7.4 | After 7.4 |
  | --- | --- |
  |`READ TABLE itab ... TRANSPORTING NO FIELDS.` </br>`IF sy-subrc = 0.` </br>`   ...` </br>`ENDIF.`|`IF line_exists( itab[ ... ] ).`</br>   `  ...`</br>`ENDIF.`|
  
- Get table index

  | Before 7.4 | After 7.4 |
  | --- | --- |
  |`DATA idx type sy-tabix.`</br> `READ TABLE ... TRANSPORTING NO FIELDS.`</br>`idx = sy-tabix.`|`DATA(idx) = line_index( itab[ ... ] ).` |


Note: There will be a short dump if you use an inline expression that references a non-existent record. SAP says you should therefore assign a field symbol and check sy-subrc.
```
ASSIGN lt_tab[ 1 ] to FIELD-SYMBOL(<ls_tab>).
IF sy-subrc = 0.
...
ENDIF.
```
Use `itab [ table_line = … ]` for untyped tables.
  
  
### Conversion Operator CONV

Syntax
```
CONV dtype|#( … )

dtype = Type you want to convert to (explicit)
#     = compiler must use the context to decide the type to convert to (implicit)
```

Example

|  Before 7.4  |  After 7.4  |
| --- | --- |
| `DATA text   TYPE c LENGTH 255.` </br>`DATA helper TYPE string.` </br>`DATA xstr   TYPE xstring.` </br>`helper = text.`</br> `xstr = cl_abap_codepage=>convert_to( source = helper ).` | `DATA text TYPE c LENGTH 255.`</br>`DATA(xstr) = cl_abap_codepage=>convert_to( source = CONV string( text ) ).`</br> OR </br> `DATA(xstr) = cl_abap_codepage=>convert_to( source = CONV #( text ) ).` |

### VALUE Operator

Syntax
```
Variables:    VALUE dtype|#( )

Structures:   VALUE dtype|#( comp1 = a1 comp2 = a2 … )

Tables:       VALUE dtype|#( ( … ) ( … ) … ) …
```

Examples
- Structures
  ```
  TYPES:  BEGIN OF ty_columns1, “Simple structure
           cols1 TYPE i,
           cols2 TYPE i,
          END OF ty_columns1.
  DATA: struc_simple TYPE ty_columns1,
  struc_simple = VALUE #( cols1 = 1
                          cols2 = 2 ).
  ```
- Internal Tables
  - New table declaration
  ```
  DATA: itab TYPE TABLE OF structure,
        wa TYPE structure.
  DATA(itab) = VALUE structure(( fld1 = 1 fld2 = 'A' )
                               ( fld1 = 2 fld2 = 'B' )).
  ```
  - Inserting lines into existing table
  ```
  itab = VALUE #( BASE itab
                  ( fld1 = 1 fld2 = 'A' ) 
                  ( fld1 = 2 fld2 = 'B' ) ).
  ```

### FOR Operator

Syntax
```
  FOR wa|<fs> IN itab [INDEX INTO idx] [cond]
```

Examples
- Before 7.4
  ```
  DATA: gt_citys TYPE ty_citys,
      gs_ship  TYPE ty_ship,
      gs_city  TYPE ort01.

  LOOP AT gt_ships INTO gs_ship.
    gs_city =  gs_ship-city.
    APPEND gs_city TO gt_citys.
  ENDLOOP.
  ```
- After 7.4
  ```
  DATA(gt_citys) = VALUE ty_citys( FOR ls_ship IN gt_ships ( ls_ship-city ) ).
  ```

### Reduction Operator REDUCE

Syantax
```
  … REDUCE type(
      INIT result = start_value
      …
      FOR for_exp1
      FOR for_exp2
      …
      NEXT …
      result = iterated_value
  … )
```
REDUCE must include at least one FOR expression.

Examples
- Before 7.4
  ```
  DATA: lv_lines TYPE i.

  LOOP AT gt_itab INTO ls_itab where F1 = ‘XYZ’.
    lv_lines = lv_lines + 1.
  ENDLOOP.
  ```
- After 7.4
  ```
  DATA(lv_lines) = REDUCE i( INIT x = 0
                             FOR wa IN gt_itab
                             WHERE( F1 = ‘XYZ’ )
                             NEXT x = x + 1 ).
  ```

### Conditional operators COND and SWITCH

Syntax
- COND
```
… COND dtype|#( WHEN log_exp1 THEN result1
[ WHEN log_exp2 THEN result2 ]
…
[ ELSE resultn ] ) …
```
- SWITCH
```
… SWITCH dtype|#( operand
WHEN const1 THEN result1
[ WHEN const2 THEN result2 ]
…
[ ELSE resultn ] ) …
```

Examples
- COND
  ```
  DATA(lv_text) = COND text30(
                     WHEN lv_vehicle ='01' AND lv_type = 'C'
                        THEN 'Toyota'
                     WHEN lv_vehicle ='02' AND lv_type = 'C'
                        THEN 'Chevy'
                     WHEN lv_vehicle ='03' AND lv_type = 'C'
                        THEN 'Range Rover').
  ```
- SWITCH
  ```
  DATA(lv_language) = SWITCH #( sy-langu
                                WHEN 'D' THEN `DE`
                                WHEN 'E' THEN `EN`
                                ELSE THROW cx_langu_not_supported( ) ).
  ```

### CORRESPONDING Operator

Syntax
```
  … CORRESPONDING type( [BASE ( base )] struct|itab [mapping|except] )
```

Example
| Before 7.4 |  After 7.4 |
| --- | --- |
| </br>`CLEAR ls_line2.` </br> `MOVE-CORRESPONDING ls_line1 TO ls_line2.`|</br>`ls_line2 = CORRESPONDING #( ls_line1 ).`|
| </br>`MOVE-CORRESPONDING ls_line1 TO ls_line2.`| </br>` ls_line2 = CORRESPONDING #( BASE ( ls_line2 ) ls_line1 ).` |
| </br>`DATA: ls_line3 like ls_line2.`</br>`ls_line3 = ls_line2.`</br>`MOVE-CORRESPONDING ls_line1 TO ls_line2.` |</br>`DATA(ls_line3) = CORRESPONDING line2`</br>`( BASE ( ls_line2 ) ls_line1 ).` |

### Strings
### Loop at Group by
### Classes and Methods
### Filter

Learn more:
- [ABAP News for Release 7.40](https://blogs.sap.com/2013/05/22/abap-news-for-release-740-2/)
- [ABAP 7.40 Quick Reference](https://blogs.sap.com/2015/10/25/abap-740-quick-reference/)
